# Obstacle Game
## Project Overview
The goal of this game was to make a challenging, yet simple game which requires the player to dodge the falling objects. The player has a free range of motion throughout the entire screen. The falling objects increase in amount and size as the game progresses. This happens at an exponential rate to make the game more fun and difficult. The scoring system (in hexidecimal) is displayed on the LCD screen, counting up after every successive enemy is avoided.

![demo](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExdWVnZzY4MHp1b24zbG11cmQzbjhhdjN6cjQ3am1ya2cxNGwza2ZnNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/MB6GcYacS74jb47K8v/giphy.gif)

## Required Hardware 
The program was designed to run on a Digilent Nexys A7-100T FPGA Trainer board as shown below. 

<img src="https://cdn11.bigcommerce.com/s-7gavg/images/stencil/1280w/products/629/5235/NexysA7-obl-600__85101.1670975737.jpg" alt="Alt text" width="300" height="200">

Additionally, a VGA to HDMI adapter was used to display the game on a modern screen. This is not a requirement for use with a display that supports VGA connection. 

<img src="https://m.media-amazon.com/images/I/61Jlht0rihL._AC_UF894,1000_QL80_.jpg" alt="Alt text" width="300" height="200">

## Vivado Uploading Process 

To play this game for yourself, first download all files from this repository and open a new project in Vivado. Add all .vhd files as sources and the pong.xdc file as a constraint. Also, make sure to select the Nexys A7 as your desired board. Next go through the process of running synthesis -> implementation -> generating bitstream -> open hardware manager -> open target -> select the Nexys A7 board if not recognized automatically (and make sure it is turned ON) -> program device. After a few seconds, the external display should show the game and you are ready to begin by pressing the center button! 

## Inputs and Outputs

Outlined in pong.xdc, the system clock, onboard VGA port, 5-button pad, and 7-segment display are all initialized for use in the program. The clock and 5 buttons are declared as inputs within pong.vhd as they control the game timing and player movement/reset respectively. The VGA and 7-segment display are set as outputs, with the VGA controlling the RGB and V/H sync of the display and the 7-segment being used to output the player score visually. Of note, the 7-segment display calls for both the "segment" and "anode" values to be declared with segment controlling the hexadecimal value to display and anode controlling which display to illuminate. 

![n4r](https://github.com/user-attachments/assets/07ebadd9-20ec-4a6a-bc2e-30ad710c9ba6)  ![n4m](https://github.com/user-attachments/assets/cec3b2b0-d77f-4226-bea9-c73170239161)

## Modifications

![imagedsfrgFZF](https://github.com/user-attachments/assets/19a64f9c-1a7c-42b4-8578-06138a72b00f)

The code is a modified version of the Lab 6 "pong" project, though much of the front end is entirely different. The clk_wiz_0.vhd, clk_wiz_0_clk_wiz.vhd, leddec16.vhd, and vga_sync.vhd source files all remained the same as they were only for setting up peripherals and did not affect the game aspect. The original bat_n_ball.vhd file was changed to obstacle_game.vhd and contains the majority of modifications. The only remnants of bat_n_ball are seen in the v_sync updating system and pixel_row/pixel_col/red/green/blue ports. The v_sync process starts with initialization of the game upon pressing of the center button or the player dying. Upon either of these happening, all obstacles are sent to positions not viewable on screen and the score, difficulty, obstacle size, and obstacle amount are all set back to their initial values. Finally, the game_over bool signal is set to false, starting a new instance of the game. With this false state, the obstacles begin to move down the screen at a rate determined by the difficulty. Once reaching the bottom of the screen, the score counter increases by one and the obstacle y values are set back to 0. As well, an equation related to the specific obstacle determines where it will be positioned on the x axis of the next stage. Though not a random process, the addition of new obstacles still proves a challenge for the player. In addition to the obstacle movement, the difficulty is also increased during the false state. At multiples of 10 based on the score, the difficulty, obstacle amount, and obstacle size values will all increase, being capped at 5, 6, and 30 respectively. While this covers the game logic of the program, the player and obstacles are not fully realized. This is completed with the collision detection and drawing process, relating to pixel_row, pixel_col, obs_x, obs_y, player_x, and player_y. First, 
the player is drawn. This is determined by using the current player position and size and comparing it to the overall pixel_row and pixel_col values. Any intersecting pixels between the two are then colored red. A similar process is done to draw the obstacles, with a for loop in place to run through each of the obstacles and determine their position. Finally, the for loop also determines if the obstacle position (with added size) and player position (with added size) are overlapping, in which case the collided boolean signal is set to TRUE which promptly ends the game. 

Though obstacle_game.vhd holds the game logic and obstacle initialization and movement, pong.vhd finishes the player experience with movement while also acting as the top level for the program, mapping all the seperate file ports to each other. To make the player move, a count signal was first created in a "pos" process to increase on every clock rising edge. On every reset of the count, which is 21 bits, the buttons and player position are checked. These player position values are also offset by 5 to account for player size and not allow the player to move off screen. In order to make the player move, the button corresponding to the desired direction is pressed and the player position is either added or subtracted 5 from the axis of movement based on the button pressed. The rest of pong.vhd remains the same as the original code in terms of port mapping, with the exception being the score mapped to display of the 7-segment and the respective buttons being mapped into obstacle_game.vhd. 

## Process Summary

The collision detection, and obstacle position randomization and automatic movement was done by Aidan and the player movement and initialization, as well as obstacle inititalization, was done by Daniel, though there was lots of cross commmunication on how to go about doing all the different processes. Initially, as stated in our presentation, we wanted to use the accelerometer to control the player movement but with limited time we switched to using the buttons. The main difficulty we had was getting the collision detection to work as the game does not register when an obstacle is over a player correctly. We tried to remedy this after our presentation but were unable to find a solution. Additionally, trying to get the obstacles to spawn in random x-axis locations proved to be a challenge, but through some online research a soltuion was eventually found. In terms of timeline, the accelerometer deep dive was started shortly after the completion of the final lab. About a week or two after we decided to pivot, with the player and obstacle draw functions complete. Mapping the buttons to the player was completed a day later and the obstacle automatic movement and exponential scaling completed a couple days after. The main trouble, as said, was the collision and randomization, though randomization was finished a couple days before presentations. 

![one-does-not-996dbfc164](https://github.com/user-attachments/assets/5954ddd8-dad5-4fa2-a23f-e90ebae39a4c)
